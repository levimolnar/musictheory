{"ast":null,"code":"export const getSpellingPath = recipe => {\n  const startingCoords = positions[recipe[0]];\n  let best = {\n    spellingPath: [],\n    accidentalCount: Infinity\n  };\n  startingCoords.forEach(([startX, _], i) => {\n    const xArray = Array.from({\n      length: recipe.length\n    }, (_, i) => (startX + i) % recipe.length);\n    let current = {\n      spellingPath: [],\n      accidentalCount: 0\n    };\n    for (let [j, x] of Object.entries(xArray)) {\n      const match = Object.entries(numberMatrix[x]).find(([_, number]) => number === recipe[+j]);\n      if (match) {\n        const [y] = match;\n        current.spellingPath.push([x, +y]);\n        current.accidentalCount += Math.abs(+y);\n      } else {\n        current.accidentalCount = Infinity;\n        break;\n      }\n      ;\n    }\n    if (current.accidentalCount < best.accidentalCount) {\n      best = {\n        ...current\n      };\n    }\n    ;\n  });\n  return best.spellingPath;\n};\nexport const getIntervalStrings = (recipe, chordLength) => {\n  const normalizeNote = n => (n % 12 + 12) % 12;\n  let intervalStrings = [];\n  for (let i = 0; i < recipe.length; i++) {\n    let string = \"\";\n    for (let j = 0; j < chordLength - 1; j++) {\n      const note1 = recipe[(i + 2 * j) % recipe.length];\n      const note2 = recipe[(i + 2 * (j + 1)) % recipe.length];\n      const interval = normalizeNote(note2 - note1);\n      string += String(interval);\n    }\n    ;\n    intervalStrings.push(string);\n  }\n  return intervalStrings;\n};","map":{"version":3,"names":["getSpellingPath","recipe","startingCoords","positions","best","spellingPath","accidentalCount","Infinity","forEach","startX","_","i","xArray","Array","from","length","current","j","x","Object","entries","match","numberMatrix","find","number","y","push","Math","abs","getIntervalStrings","chordLength","normalizeNote","n","intervalStrings","string","note1","note2","interval","String"],"sources":["C:/Users/Levi/Desktop/portfolio/src/Chart/modeFunctions.tsx"],"sourcesContent":["export const getSpellingPath = (recipe: number[]) => {\n  const startingCoords = positions[recipe[0]];\n\n  let best: {spellingPath: Array<[number, number]>, accidentalCount: number} = {spellingPath: [], accidentalCount: Infinity};\n\n  startingCoords.forEach(([startX, _], i) => {\n    const xArray = Array.from({length: recipe.length}, (_, i) => (startX + i) % (recipe.length));\n    let current: {spellingPath: Array<[number, number]>, accidentalCount: number} = {spellingPath: [], accidentalCount: 0};\n\n    for (let [j, x] of Object.entries(xArray)) {\n      const match = Object.entries(numberMatrix[x]).find(([_, number]) => number === recipe[+j]);\n      if (match) {\n        const [y] = match;\n        current.spellingPath.push([x, +y]);\n        current.accidentalCount += Math.abs(+y);\n      } else {\n        current.accidentalCount = Infinity;\n        break;\n      };\n    }\n\n    if (current.accidentalCount < best.accidentalCount) { best = {...current} };\n  }); \n\n  return best.spellingPath;\n}\n\nexport const getIntervalStrings = (recipe: number[], chordLength: number) => {\n  const normalizeNote = (n: number) => (n % 12 + 12) % 12;\n\n  let intervalStrings = [];\n\n  for (let i = 0; i < recipe.length; i++) {\n\n    let string = \"\";\n\n    for (let j = 0; j < (chordLength - 1); j++) {\n      const note1 = recipe[(i + 2*j) % recipe.length];\n      const note2 = recipe[(i + 2*(j+1)) % recipe.length];\n      const interval = normalizeNote(note2 - note1);\n      string += String(interval);\n    };\n\n    intervalStrings.push(string);\n  }\n\n  return intervalStrings;\n}"],"mappings":"AAAA,OAAO,MAAMA,eAAe,GAAIC,MAAgB,IAAK;EACnD,MAAMC,cAAc,GAAGC,SAAS,CAACF,MAAM,CAAC,CAAC,CAAC,CAAC;EAE3C,IAAIG,IAAsE,GAAG;IAACC,YAAY,EAAE,EAAE;IAAEC,eAAe,EAAEC;EAAQ,CAAC;EAE1HL,cAAc,CAACM,OAAO,CAAC,CAAC,CAACC,MAAM,EAAEC,CAAC,CAAC,EAAEC,CAAC,KAAK;IACzC,MAAMC,MAAM,GAAGC,KAAK,CAACC,IAAI,CAAC;MAACC,MAAM,EAAEd,MAAM,CAACc;IAAM,CAAC,EAAE,CAACL,CAAC,EAAEC,CAAC,KAAK,CAACF,MAAM,GAAGE,CAAC,IAAKV,MAAM,CAACc,MAAO,CAAC;IAC5F,IAAIC,OAAyE,GAAG;MAACX,YAAY,EAAE,EAAE;MAAEC,eAAe,EAAE;IAAC,CAAC;IAEtH,KAAK,IAAI,CAACW,CAAC,EAAEC,CAAC,CAAC,IAAIC,MAAM,CAACC,OAAO,CAACR,MAAM,CAAC,EAAE;MACzC,MAAMS,KAAK,GAAGF,MAAM,CAACC,OAAO,CAACE,YAAY,CAACJ,CAAC,CAAC,CAAC,CAACK,IAAI,CAAC,CAAC,CAACb,CAAC,EAAEc,MAAM,CAAC,KAAKA,MAAM,KAAKvB,MAAM,CAAC,CAACgB,CAAC,CAAC,CAAC;MAC1F,IAAII,KAAK,EAAE;QACT,MAAM,CAACI,CAAC,CAAC,GAAGJ,KAAK;QACjBL,OAAO,CAACX,YAAY,CAACqB,IAAI,CAAC,CAACR,CAAC,EAAE,CAACO,CAAC,CAAC,CAAC;QAClCT,OAAO,CAACV,eAAe,IAAIqB,IAAI,CAACC,GAAG,CAAC,CAACH,CAAC,CAAC;MACzC,CAAC,MAAM;QACLT,OAAO,CAACV,eAAe,GAAGC,QAAQ;QAClC;MACF;MAAC;IACH;IAEA,IAAIS,OAAO,CAACV,eAAe,GAAGF,IAAI,CAACE,eAAe,EAAE;MAAEF,IAAI,GAAG;QAAC,GAAGY;MAAO,CAAC;IAAC;IAAC;EAC7E,CAAC,CAAC;EAEF,OAAOZ,IAAI,CAACC,YAAY;AAC1B,CAAC;AAED,OAAO,MAAMwB,kBAAkB,GAAGA,CAAC5B,MAAgB,EAAE6B,WAAmB,KAAK;EAC3E,MAAMC,aAAa,GAAIC,CAAS,IAAK,CAACA,CAAC,GAAG,EAAE,GAAG,EAAE,IAAI,EAAE;EAEvD,IAAIC,eAAe,GAAG,EAAE;EAExB,KAAK,IAAItB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGV,MAAM,CAACc,MAAM,EAAEJ,CAAC,EAAE,EAAE;IAEtC,IAAIuB,MAAM,GAAG,EAAE;IAEf,KAAK,IAAIjB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAIa,WAAW,GAAG,CAAE,EAAEb,CAAC,EAAE,EAAE;MAC1C,MAAMkB,KAAK,GAAGlC,MAAM,CAAC,CAACU,CAAC,GAAG,CAAC,GAACM,CAAC,IAAIhB,MAAM,CAACc,MAAM,CAAC;MAC/C,MAAMqB,KAAK,GAAGnC,MAAM,CAAC,CAACU,CAAC,GAAG,CAAC,IAAEM,CAAC,GAAC,CAAC,CAAC,IAAIhB,MAAM,CAACc,MAAM,CAAC;MACnD,MAAMsB,QAAQ,GAAGN,aAAa,CAACK,KAAK,GAAGD,KAAK,CAAC;MAC7CD,MAAM,IAAII,MAAM,CAACD,QAAQ,CAAC;IAC5B;IAAC;IAEDJ,eAAe,CAACP,IAAI,CAACQ,MAAM,CAAC;EAC9B;EAEA,OAAOD,eAAe;AACxB,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}