{"ast":null,"code":"import { v4 as uuidv4 } from 'uuid';\nimport { chordIntervals } from './chordIntervals';\n\n// const defScaleObject = {\n//   \"Diatonic\": {\n//     \"lydian\":     [0,2,4,6,7,9,11], \n//     \"ionian\":     [0,2,4,5,7,9,11], \n//     \"mixolydian\": [0,2,4,5,7,9,10], \n//     \"dorian\":     [0,2,3,5,7,9,10], \n//     \"aeolian\":    [0,2,3,5,7,8,10], \n//     \"phrygian\":   [0,1,3,5,7,8,10], \n//     \"locrian\":    [0,1,3,5,6,8,10],\n//   },\n// }\n\nconst numberMatrix = [{\n  [-2]: 10,\n  [-1]: 11,\n  0: 0,\n  1: 1,\n  2: 2\n}, {\n  [-2]: 0,\n  [-1]: 1,\n  0: 2,\n  1: 3,\n  2: 4\n}, {\n  [-2]: 2,\n  [-1]: 3,\n  0: 4,\n  1: 5,\n  2: 6\n}, {\n  [-2]: 3,\n  [-1]: 4,\n  0: 5,\n  1: 6,\n  2: 7\n}, {\n  [-2]: 5,\n  [-1]: 6,\n  0: 7,\n  1: 8,\n  2: 9\n}, {\n  [-2]: 7,\n  [-1]: 8,\n  0: 9,\n  1: 10,\n  2: 11\n}, {\n  [-2]: 9,\n  [-1]: 10,\n  0: 11,\n  1: 0,\n  2: 1\n}];\nconst characterMatrix = [{\n  [-2]: 'C\\uED64',\n  [-1]: 'C\\uED60',\n  0: 'C',\n  1: 'C\\uED62',\n  2: 'C\\uED63'\n}, {\n  [-2]: 'D\\uED64',\n  [-1]: 'D\\uED60',\n  0: 'D',\n  1: 'D\\uED62',\n  2: 'D\\uED63'\n}, {\n  [-2]: 'E\\uED64',\n  [-1]: 'E\\uED60',\n  0: 'E',\n  1: 'E\\uED62',\n  2: 'E\\uED63'\n}, {\n  [-2]: 'F\\uED64',\n  [-1]: 'F\\uED60',\n  0: 'F',\n  1: 'F\\uED62',\n  2: 'F\\uED63'\n}, {\n  [-2]: 'G\\uED64',\n  [-1]: 'G\\uED60',\n  0: 'G',\n  1: 'G\\uED62',\n  2: 'G\\uED63'\n}, {\n  [-2]: 'A\\uED64',\n  [-1]: 'A\\uED60',\n  0: 'A',\n  1: 'A\\uED62',\n  2: 'A\\uED63'\n}, {\n  [-2]: 'B\\uED64',\n  [-1]: 'B\\uED60',\n  0: 'B',\n  1: 'B\\uED62',\n  2: 'B\\uED63'\n}];\nconst positions = [[[0, 0], [6, 1], [1, -2]], [[1, -1], [0, 1], [6, 2]], [[1, 0], [2, -2], [0, 2]], [[2, -1], [1, 1], [3, -2]], [[2, 0], [3, -1], [1, 2]], [[3, 0], [2, 1], [4, -2]], [[4, -1], [3, 1], [2, 2]], [[4, 0], [5, -2], [3, 2]], [[5, -1], [4, 1]], [[5, 0], [6, -2], [4, 2]], [[6, -1], [5, 1], [0, -2]], [[6, 0], [0, -1], [5, 2]]];\nexport class ModeList {\n  constructor(modeObj = {}, transpose = 0) {\n    this.modes = void 0;\n    this.transpose = void 0;\n    this.modes = [];\n    this.transpose = transpose;\n    Object.entries(modeObj).forEach(([name, recipe]) => this.addMode(name, recipe));\n  }\n  addMode(modeName, modeRecipe) {\n    const transposedRecipe = Array.from(modeRecipe, i => (i + this.transpose) % 12);\n    // const startingCoords = positions[this.transpose];\n    // this.modes.push(new Mode(modeName, transposedRecipe, startingCoords));\n    this.modes.push(new Mode(modeName, transposedRecipe));\n  }\n}\nclass Mode {\n  constructor(modeName, modeRecipe, startingCoords) {\n    this.name = void 0;\n    this.length = void 0;\n    this.chords = void 0;\n    this.name = modeName;\n    this.length = modeRecipe.length;\n    this.chords = [];\n\n    // 01: FIND SPELLING WITH LEAST ACCIDENTALS USED\n\n    // let best: {spellingPath: Array<[number, number]>, accidentalCount: number} = {spellingPath: [], accidentalCount: Infinity};\n\n    // startingCoords.forEach(([startX, _], i) => {\n    //   const xArray = Array.from({length: this.length}, (_, i) => (startX + i) % (this.length));\n    //   let current: {spellingPath: Array<[number, number]>, accidentalCount: number} = {spellingPath: [], accidentalCount: 0};\n\n    //   for (let [j, x] of Object.entries(xArray)) {\n    //     const match = Object.entries(numberMatrix[x]).find(([_, number]) => number === modeRecipe[+j]);\n    //     if (match) {\n    //       const [y] = match;\n    //       current.spellingPath.push([x, +y]);\n    //       current.accidentalCount += Math.abs(+y);\n    //     } else {\n    //       current.accidentalCount = Infinity;\n    //       break;\n    //     };\n    //   }\n\n    //   if (current.accidentalCount < best.accidentalCount) { best = {...current} };\n    // });\n\n    const spellingPath = this.getBestSpelling();\n\n    // 02: FIND INTERVALS THAT MAKE UP CHORDS\n\n    const intervalStrings = this.getIntervalStrings(modeRecipe, 4);\n\n    // 03: ADD CHORD OBJECTS\n\n    for (let i = 0; i < this.length; i++) {\n      // const [x, y] = best.spellingPath[i];\n      const [x, y] = spellingPath[i];\n      this.chords.push(new Chord(characterMatrix[x][y], intervalStrings[i]));\n    }\n    ;\n  }\n  getBestSpelling() {\n    let best = {\n      spellingPath: [],\n      accidentalCount: Infinity\n    };\n    startingCoords.forEach(([startX, _], i) => {\n      const xArray = Array.from({\n        length: this.length\n      }, (_, i) => (startX + i) % this.length);\n      let current = {\n        spellingPath: [],\n        accidentalCount: 0\n      };\n      for (let [j, x] of Object.entries(xArray)) {\n        const match = Object.entries(numberMatrix[x]).find(([_, number]) => number === modeRecipe[+j]);\n        if (match) {\n          const [y] = match;\n          current.spellingPath.push([x, +y]);\n          current.accidentalCount += Math.abs(+y);\n        } else {\n          current.accidentalCount = Infinity;\n          break;\n        }\n        ;\n      }\n      if (current.accidentalCount < best.accidentalCount) {\n        best = {\n          ...current\n        };\n      }\n      ;\n    });\n    return best.spellingPath;\n  }\n  getIntervalStrings(recipe, chordLength) {\n    const normalizeNote = n => (n % 12 + 12) % 12;\n    let intervalStrings = [];\n    for (let i = 0; i < recipe.length; i++) {\n      let string = \"\";\n      for (let j = 0; j < chordLength - 1; j++) {\n        const note1 = recipe[(i + 2 * j) % recipe.length];\n        const note2 = recipe[(i + 2 * (j + 1)) % recipe.length];\n        const interval = normalizeNote(note2 - note1);\n        string += String(interval);\n      }\n      ;\n      intervalStrings.push(string);\n    }\n    return intervalStrings;\n  }\n} // addChord() { this.chords.push(new Chord()) }\n\nclass Chord {\n  constructor(root, intervalString) {\n    this.id = void 0;\n    this.root = void 0;\n    this.type = void 0;\n    this.numeral = void 0;\n    this.id = uuidv4();\n    this.root = root;\n    this.type = this.lookupChordType(intervalString);\n    this.numeral = undefined;\n  }\n  lookupChordType(intervalString) {\n    return chordIntervals[+intervalString];\n  }\n}","map":{"version":3,"names":["v4","uuidv4","chordIntervals","numberMatrix","characterMatrix","positions","ModeList","constructor","modeObj","transpose","modes","Object","entries","forEach","name","recipe","addMode","modeName","modeRecipe","transposedRecipe","Array","from","i","push","Mode","startingCoords","length","chords","spellingPath","getBestSpelling","intervalStrings","getIntervalStrings","x","y","Chord","best","accidentalCount","Infinity","startX","_","xArray","current","j","match","find","number","Math","abs","chordLength","normalizeNote","n","string","note1","note2","interval","String","root","intervalString","id","type","numeral","lookupChordType","undefined"],"sources":["C:/Users/Levi/Desktop/portfolio/src/Chart/pitchSpellerOOP.ts"],"sourcesContent":["import { v4 as uuidv4 } from 'uuid';\r\nimport { chordIntervals } from './chordIntervals';\r\n\r\n// const defScaleObject = {\r\n//   \"Diatonic\": {\r\n//     \"lydian\":     [0,2,4,6,7,9,11], \r\n//     \"ionian\":     [0,2,4,5,7,9,11], \r\n//     \"mixolydian\": [0,2,4,5,7,9,10], \r\n//     \"dorian\":     [0,2,3,5,7,9,10], \r\n//     \"aeolian\":    [0,2,3,5,7,8,10], \r\n//     \"phrygian\":   [0,1,3,5,7,8,10], \r\n//     \"locrian\":    [0,1,3,5,6,8,10],\r\n//   },\r\n// }\r\n\r\nconst numberMatrix: Array<{[key: number]: number}> = [\r\n  {[-2]: 10, [-1]: 11, 0:  0, 1:  1, 2:  2},\r\n  {[-2]:  0, [-1]:  1, 0:  2, 1:  3, 2:  4},\r\n  {[-2]:  2, [-1]:  3, 0:  4, 1:  5, 2:  6},\r\n  {[-2]:  3, [-1]:  4, 0:  5, 1:  6, 2:  7},\r\n  {[-2]:  5, [-1]:  6, 0:  7, 1:  8, 2:  9},\r\n  {[-2]:  7, [-1]:  8, 0:  9, 1: 10, 2: 11},\r\n  {[-2]:  9, [-1]: 10, 0: 11, 1:  0, 2:  1},\r\n]\r\n\r\nconst characterMatrix: Array<{[key: number]: string}> = [\r\n  {[-2]: 'C\\uED64', [-1]: 'C\\uED60', 0: 'C', 1: 'C\\uED62', 2: 'C\\uED63'},\r\n  {[-2]: 'D\\uED64', [-1]: 'D\\uED60', 0: 'D', 1: 'D\\uED62', 2: 'D\\uED63'},\r\n  {[-2]: 'E\\uED64', [-1]: 'E\\uED60', 0: 'E', 1: 'E\\uED62', 2: 'E\\uED63'},\r\n  {[-2]: 'F\\uED64', [-1]: 'F\\uED60', 0: 'F', 1: 'F\\uED62', 2: 'F\\uED63'},\r\n  {[-2]: 'G\\uED64', [-1]: 'G\\uED60', 0: 'G', 1: 'G\\uED62', 2: 'G\\uED63'},\r\n  {[-2]: 'A\\uED64', [-1]: 'A\\uED60', 0: 'A', 1: 'A\\uED62', 2: 'A\\uED63'},\r\n  {[-2]: 'B\\uED64', [-1]: 'B\\uED60', 0: 'B', 1: 'B\\uED62', 2: 'B\\uED63'},\r\n]\r\n\r\n\r\nconst positions: Array<Array<[number, number]>> = [\r\n  [[0, 0], [6, 1], [1,-2]],\r\n  [[1,-1], [0, 1], [6, 2]],\r\n  [[1, 0], [2,-2], [0, 2]],\r\n  [[2,-1], [1, 1], [3,-2]],\r\n  [[2, 0], [3,-1], [1, 2]],\r\n  [[3, 0], [2, 1], [4,-2]],\r\n  [[4,-1], [3, 1], [2, 2]],\r\n  [[4, 0], [5,-2], [3, 2]],\r\n  [[5,-1], [4, 1]],\r\n  [[5, 0], [6,-2], [4, 2]],\r\n  [[6,-1], [5, 1], [0,-2]],\r\n  [[6, 0], [0,-1], [5, 2]],\r\n]\r\n\r\nexport class ModeList {\r\n  modes: Array<any>\r\n  transpose: number;\r\n\r\n  constructor(modeObj: {[key: string]: number[]} = {}, transpose: number = 0) {\r\n    this.modes = [];\r\n    this.transpose = transpose;\r\n    Object.entries(modeObj).forEach(([name, recipe]) => this.addMode(name, recipe));\r\n  }\r\n\r\n  addMode(modeName: string, modeRecipe: number[]) {\r\n    const transposedRecipe = Array.from(modeRecipe, (i) => (i + this.transpose) % 12);\r\n    // const startingCoords = positions[this.transpose];\r\n    // this.modes.push(new Mode(modeName, transposedRecipe, startingCoords));\r\n    this.modes.push(new Mode(modeName, transposedRecipe));\r\n  }\r\n}\r\n\r\nclass Mode {\r\n  name: string;\r\n  length: number;\r\n  chords: Array<Object>;\r\n\r\n  constructor(modeName: string, modeRecipe: number[], startingCoords: Array<[number, number]>) {\r\n    this.name = modeName;\r\n    this.length = modeRecipe.length;\r\n    this.chords = [];\r\n\r\n    // 01: FIND SPELLING WITH LEAST ACCIDENTALS USED\r\n\r\n    // let best: {spellingPath: Array<[number, number]>, accidentalCount: number} = {spellingPath: [], accidentalCount: Infinity};\r\n\r\n    // startingCoords.forEach(([startX, _], i) => {\r\n    //   const xArray = Array.from({length: this.length}, (_, i) => (startX + i) % (this.length));\r\n    //   let current: {spellingPath: Array<[number, number]>, accidentalCount: number} = {spellingPath: [], accidentalCount: 0};\r\n\r\n    //   for (let [j, x] of Object.entries(xArray)) {\r\n    //     const match = Object.entries(numberMatrix[x]).find(([_, number]) => number === modeRecipe[+j]);\r\n    //     if (match) {\r\n    //       const [y] = match;\r\n    //       current.spellingPath.push([x, +y]);\r\n    //       current.accidentalCount += Math.abs(+y);\r\n    //     } else {\r\n    //       current.accidentalCount = Infinity;\r\n    //       break;\r\n    //     };\r\n    //   }\r\n\r\n    //   if (current.accidentalCount < best.accidentalCount) { best = {...current} };\r\n    // });\r\n\r\n    const spellingPath = this.getBestSpelling();\r\n\r\n    // 02: FIND INTERVALS THAT MAKE UP CHORDS\r\n\r\n    const intervalStrings = this.getIntervalStrings(modeRecipe, 4);\r\n\r\n    // 03: ADD CHORD OBJECTS\r\n\r\n    for (let i = 0; i < this.length; i++) {\r\n      // const [x, y] = best.spellingPath[i];\r\n      const [x, y] = spellingPath[i];\r\n      this.chords.push(new Chord(characterMatrix[x][y], intervalStrings[i]));\r\n    };\r\n  }\r\n\r\n  getBestSpelling() {\r\n    let best: {spellingPath: Array<[number, number]>, accidentalCount: number} = {spellingPath: [], accidentalCount: Infinity};\r\n\r\n    startingCoords.forEach(([startX, _], i) => {\r\n      const xArray = Array.from({length: this.length}, (_, i) => (startX + i) % (this.length));\r\n      let current: {spellingPath: Array<[number, number]>, accidentalCount: number} = {spellingPath: [], accidentalCount: 0};\r\n\r\n      for (let [j, x] of Object.entries(xArray)) {\r\n        const match = Object.entries(numberMatrix[x]).find(([_, number]) => number === modeRecipe[+j]);\r\n        if (match) {\r\n          const [y] = match;\r\n          current.spellingPath.push([x, +y]);\r\n          current.accidentalCount += Math.abs(+y);\r\n        } else {\r\n          current.accidentalCount = Infinity;\r\n          break;\r\n        };\r\n      }\r\n\r\n      if (current.accidentalCount < best.accidentalCount) { best = {...current} };\r\n    }); \r\n\r\n    return best.spellingPath;\r\n  };\r\n\r\n  getIntervalStrings(recipe: number[], chordLength: number) {\r\n    const normalizeNote = (n: number) => (n % 12 + 12) % 12;\r\n\r\n    let intervalStrings = [];\r\n\r\n    for (let i = 0; i < recipe.length; i++) {\r\n\r\n      let string = \"\";\r\n\r\n      for (let j = 0; j < (chordLength - 1); j++) {\r\n        const note1 = recipe[(i + 2*j) % recipe.length];\r\n        const note2 = recipe[(i + 2*(j+1)) % recipe.length];\r\n        const interval = normalizeNote(note2 - note1);\r\n        string += String(interval);\r\n      };\r\n\r\n      intervalStrings.push(string);\r\n    }\r\n\r\n    return intervalStrings;\r\n  };\r\n\r\n  // addChord() { this.chords.push(new Chord()) }\r\n}\r\n\r\nclass Chord {\r\n  id: string;\r\n  root: string;\r\n  type: {\r\n    full: string,\r\n    short: string,\r\n    symbol: string,\r\n  };\r\n  numeral: undefined;\r\n\r\n  constructor(root: string, intervalString: string) {\r\n    this.id = uuidv4();\r\n    this.root = root;\r\n    this.type = this.lookupChordType(intervalString);\r\n    this.numeral = undefined;\r\n  }\r\n\r\n  lookupChordType(intervalString: string) {\r\n    return chordIntervals[+intervalString]\r\n  }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}